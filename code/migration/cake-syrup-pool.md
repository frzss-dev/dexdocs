---
description: Migrate to new FRZW Syrup Pool
---

# FRZW Syrup Pool

The new CakePool is a new $FRZW staking contract built based on the CakeVault (the current auto FRZW pool) and designed to work with FRZDEX MasterChef v2 to provide "stake $FRZW, earn $FRZW" functionality while offering more features such as fixed-term staking. The current Manual FRZW pool will be retired after the migration.

The new CakePool will use a dummy token to harvest $FRZW from MasterChef v2 and reward them to users who are staking $FRZW. Users who lock their $FRZW for longer will receive a more significant number of shares (boosted linearly based on duration), therefore, enjoy a higher yield.

### Do I need to migrate?&#x20;

If you are currently using `enterStaking` and `leaveStaking` on the FRZDEX MasterChef ([0x73feaa1eE314F8c655E354234017bE2193C9E24E](https://bscscan.com/address/0x73feaa1eE314F8c655E354234017bE2193C9E24E)), you will need to migrate to the new contract.

### No more compounding

With the new CakePool, rewards are distributed proportionally to all pool users based on shares. Similar to “interest-bearing tokens” or other share-based models, users’ staking balance will grow when more rewards are being put into the pool. Users don’t need to harvest and compound their rewards.

### Fees&#x20;

In the new CakePool, all flexible staking users will be subjected to two sets of fees.&#x20;

#### Fee on flexible staking rewards&#x20;

A 2% fee will apply to all the rewards generated by flexible staking. The amount of the fee will be calculated and realized upon the next deposit or withdrawal action, cut from users’ shares. To query the number of the unrealized performance fee, use `calculatePerformanceFee(address _user)`.&#x20;

#### Withdrawal fee&#x20;

A 0.1% withdrawal fee will apply to the unstaking amount if you withdraw within 72 hours of the last deposit action. The withdrawal fee is cut from the final withdrawal amount before the FRZW transfer.

### Overview

#### Deposit

If you are currently using the `enterStaking(uint256 _amount)` on the current FRZDEX MasterChef. You need to migrate to `deposit(uint256 _amount, uint256 _lockDuration)`. For flexible staking, simply use “0” as `_lockDuration`.

#### Staking Balance and Fees

```
Global variables: CakePoolContract // FRZW pool contract
struct UserInfo {
    uint256 shares; // number of shares for a user.
    uint256 lastDepositedTime; // timestamp of the last deposit action
    uint256 cakeAtLastUserAction; // number of FRZW at the last user action
    uint256 lastUserActionTime; // timestamp of the last user action
    uint256 lockStartTime; // timestamp of the start of the lock.
    uint256 lockEndTime; // timestamp of the end of the lock.
    uint256 userBoostedShare; // the amount of shares boosted/added to the user.
    bool locked; // status of the lock
    uint256 lockedAmount; // number of FRZW locked at the start of the lock period.
}
```

**FRZW staking amount (before subtracting all the fees)**

```
const userInfo. = await CakePoolContract.userInfo(address);
const PricePerFullShare = await CakePoolContract.getPricePerFullShare();
const cakeAmount = userInfo.shares * PricePerFullShare / 1e18 - userInfo.userBoostedShare ;  // cake amount (wei), in flexible staking, userInfo.userBoostedShare should be 0.
```

**Performance Fee**

Query from contract:

```
const performanceFeeAmount = await CakePoolContract.calculatePerformanceFee(address);
```

Calculate it manually:

```
async function calculatePerformanceFeeAmount(_user:address){
    const user = await CakePoolContract.userInfo(address);
    const isFreeFee = await CakePoolContract.freeFeeUsers(_user);  //normal free fee users are some special contracts , so you can set default false

    if(user.shares > 0 && !user.locked && !isFreeFee){
        const PricePerFullShare = await CakePoolContract.getPricePerFullShare();
        uint256 totalAmount = user.shares * PricePerFullShare / 1e18; 
        uint256 earnAmount = totalAmount - user.cakeAtLastUserAction;
        uint256 performanceFee = await  CakePoolContract.performanceFee();
        uint256 currentPerformanceFee = (earnAmount * performanceFee) / 10000;
        return currentPerformanceFee;
    }
    return 0;
}
```

**Overdue Fee: (only applies to locked staking)**

Query from contract:

```
const overdueFeeAmount = await CakePoolContract.calculateOverdueFee(address);
```

Calculate it manually:

```
async function calculateOverdueFee(_user:address){
    const user = await CakePoolContract.userInfo(address);
    const isFreeFee = await CakePoolContract.freeFeeUsers(_user); //normal free fee users are some special contracts , so you can set default false
    const UNLOCK_FREE_DURATION = 1 week seconds (or you can get from smart contract,  const UNLOCK_FREE_DURATION = await CakePoolContract.UNLOCK_FREE_DURATION())
    const DURATION_FACTOR_OVERDUE = 180 * 24 * 3600; // 180 days, in order to calculate overdue fee. you can get it from contract too.

    if (
        user.shares > 0 &&
        user.locked &&
        !isFreeFee &&
        ((user.lockEndTime + UNLOCK_FREE_DURATION) < block.timestamp)
    ) {
        const PricePerFullShare = await CakePoolContract.getPricePerFullShare();
        uint256 currentAmount = user.shares * PricePerFullShare / 1e18 - user.userBoostedShare;
        uint256 earnAmount = currentAmount - user.lockedAmount;
        uint256 overdueDuration = block.timestamp - user.lockEndTime - UNLOCK_FREE_DURATION;  //  you can use UTC timestamp to replace current block.timestamp.
        if (overdueDuration > DURATION_FACTOR_OVERDUE) {
            overdueDuration = DURATION_FACTOR_OVERDUE;
        }
        // Rates are calculated based on the user's overdue duration.
        uint256 overdueWeight = (overdueDuration * overdueFee) / DURATION_FACTOR_OVERDUE;
        uint256 currentOverdueFee = (earnAmount * overdueWeight) / PRECISION_FACTOR;
        return currentOverdueFee;
    }
    return 0;
}
```

**Withdraw Fee**

```
const user = await CakePoolContract.userInfo(address);
const withdrawFee = await  CakePoolContract.withdrawFee();
const isFreeFee = await CakePoolContract.freeFeeUsers(_user); //normal free fee users are some special contracts , so you can set default false
let WithdrawFeeAmount = 0;
// you can use UTC timestamp to replace current block.timestamp.
// withdrawFeePeriod = 72 * 3600 (S)
// _amount : withdraw amount
if (!isFreeFee && (block.timestamp < user.lastDepositedTime + withdrawFeePeriod)) {
     WithdrawFeeAmount = _amount * withdrawFee;
}
```

**FRZW staking amount (after subtracting all the fees)**

```
const user = await CakePoolContract.userInfo(address);
const cakeAmountWithoutFee =  cakeAmount - (!user.locked ? performanceFeeAmount : overdueFeeAmount) - withdrawFeeAmount
```

#### Pending Rewards&#x20;

Please note that the new pool does not require any compounding. Rewards are being put into your staking balance automatically.

However, you can query the number of FRZW earned since the last action, using the difference between the current staking balance (mentioned above), and the number from `userInfo.cakeAtLastUserAction`.

#### Withdraw

If you are using the `leaveStaking(uint256 _amount)` method on the current FRZDEX MasterChef. You need to migrate to `withdraw(uint256 _shares)`.

When doing flexible staking. Please note that upon withdrawing, the pending reward fees will be calculated and cut from the number of users’ shares, the actual number of shares being withdrawn will be re-calibrated, based on the percentage of the shares you are withdrawing against the total shares you have. See the example below:

```
// the number of FRZW being withdrawn can be calculated by:
withdrawPercentage = _sharesToWithdraw / userInfo.shares
stakingBalance = userInfo.shares * PricePerFullShare / 1e18 - userInfo.userBoostedShare - !userInfo.locked ? calculatePerformanceFee(_userAddress) : calculateOverdueFee(_userAddress)
finalWithdrawAmount = withdrawPercentage * stakingBalance
```

Please note that the final receiving amount will be affected by withdraw fee. If your function relies crucially on the final number of FRZW being withdrawn, we recommend calculating that using the difference in FRZW balance before and after the withdrawal action:

```
cakeBalPrev = FRZW.balanceOf(address(this))
CakePool.withdraw(_sharesToWithdraw)
cakeBalNew = FRZW.balanceOf(address(this))
cakeWithdrawn = cakeBalNew - cakeBalPrev
```

Or, calculate and subtract the withdraw fee when estimating the amount.

#### How to calculate the FRZW per block distributed to the new FRZW pool?

Previously, the manual FRZW pool had a fixed 10 FRZW/block emission. After migrating to MasterChef v2 and the new FRZW pool, we can now adjust its emissions.

And here's how you can calculate the FRZW per block distributed to the new FRZW pool:

`cakePerBlockToPool = MasterChef.cakePerBlock(false) * (cakePool.allocPoint / MasterChef.totalSpecialAllocPoint)`

You can query the `cakePool.allocPoint` using `MasterChef.poolInfo(0)`

### **Mainnet Contract Address**

**Contract name:** CakePool\
**Contract address:** `0x45c54210128a065de780C4B0Df3d16664f7f859e`

[View the FRZDEX: Cake Pool Contract on BscScan.](https://bscscan.com/address/0x45c54210128a065de780C4B0Df3d16664f7f859e)****

### **Testnet Environment**

You can use the following testnet environment to test the integration of your project with the new FRZDEX FRZW Pool. If you have any questions, please contact our team via the existing channels, or reach out to bun@FRZDEX.com via Email.

**Dummy Tokens:**

* $FRZW: `0xFa60D973F7642B748046464e165A65B7323b0DEE`\
  (mintable by using `mint(address _to, uint256 _amount) public`)
* $WBNB: `0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd`

#### Factory and Router

* Factory v2: `0x6725F303b657a9451d8BA641348b6761A6CC7a17`
* Router v2: `0xD99D1c33F9fC3444f8101754aBC46c52416550D1`

#### MasterChefs

* v1: `0x1ED62c7b76AD29Bfb80F3329d1ce7e760aAD153d`
  * pid0: Manual FRZW
  * pid4: Dummy Pool for MasterChef v2
* v2: `0xB4A466911556e39210a6bB2FaECBB59E4eB7E43d`

#### New FRZW Pool

`0x683433ba14e8F26774D43D3E90DA6Dd7a22044Fe`
